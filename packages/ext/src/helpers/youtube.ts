import { MinimalVideoData } from "../types/client";
import { BaseHelper } from "./base";

import { VideoDataSubtitle } from "@vot.js/core/types/client";
import { availableLangs } from "@vot.js/shared/consts";
import { RequestLang } from "@vot.js/shared/types/data";
import Logger from "@vot.js/shared/utils/logger";
import { normalizeLang } from "@vot.js/shared/utils/utils";
import * as YouTubeType from "../types/helpers/youtube";

declare global {
  const yt: YouTubeType.YoutubeWindow["yt"];
  const ytcfg: YouTubeType.YoutubeWindow["ytcfg"];
}

export default class YoutubeHelper extends BaseHelper {
  static isMobile() {
    return /^m\.youtube\.com$/.test(window.location.hostname);
  }

  static getPlayer() {
    if (
      window.location.pathname.startsWith("/shorts/") &&
      !YoutubeHelper.isMobile()
    ) {
      return document.querySelector<YouTubeType.PlayerElement>(
        "#shorts-player",
      );
    }

    return document.querySelector<YouTubeType.PlayerElement>("#movie_player");
  }

  static getPlayerResponse() {
    return YoutubeHelper.getPlayer()?.getPlayerResponse?.call(undefined);
  }

  static getPlayerData() {
    return YoutubeHelper.getPlayer()?.getVideoData?.call(undefined);
  }

  /**
   * @returns volume in 0.00 - 1.00 range
   */
  static getVolume() {
    const player = YoutubeHelper.getPlayer();
    if (player?.getVolume) {
      return player.getVolume() / 100;
    }

    return 1;
  }

  static setVolume(volume: number) {
    const player = YoutubeHelper.getPlayer();
    if (player?.setVolume) {
      player.setVolume(Math.round(volume * 100));
      return true;
    }

    return false;
  }

  static isMuted() {
    const player = YoutubeHelper.getPlayer();
    if (player?.isMuted) {
      return player.isMuted();
    }

    return false;
  }

  /**
   * time in ms
   */
  static videoSeek(video: HTMLVideoElement, time: number) {
    Logger.log("videoSeek", time);
    const preTime =
      YoutubeHelper.getPlayer()?.getProgressState()?.seekableEnd ??
      video.currentTime;
    const finalTime = preTime - time;
    video.currentTime = finalTime;
  }

  /**
   * i guess it doesn't work on mobile. Maybe I'll fix it later
   */
  static getPoToken() {
    const player = YoutubeHelper.getPlayer();
    if (!player) {
      return undefined;
    }

    const audioTrack = player.getAudioTrack?.call(undefined);
    if (!audioTrack?.captionTracks?.length) {
      return undefined;
    }

    const audioTrackWithPoToken = audioTrack.captionTracks.find(
      (captionTrack) => captionTrack.url.includes("&pot="),
    );
    if (!audioTrackWithPoToken) {
      return undefined;
    }

    return /&pot=([^&]+)/.exec(audioTrackWithPoToken.url)?.[1];
  }

  static getGlobalConfig() {
    if (typeof yt !== "undefined") {
      return yt?.config_;
    }

    return typeof ytcfg !== "undefined" ? ytcfg?.data_ : undefined;
  }

  static getDeviceParams() {
    const ytconfig = YoutubeHelper.getGlobalConfig();
    if (!ytconfig) {
      return "c=WEB";
    }

    const innertubeClient = ytconfig.INNERTUBE_CONTEXT?.client;
    const deviceParams = new URLSearchParams(ytconfig.DEVICE);
    deviceParams.delete("ceng");
    deviceParams.delete("cengver");
    deviceParams.set(
      "c",
      innertubeClient?.clientName ?? ytconfig.INNERTUBE_CLIENT_NAME,
    );
    deviceParams.set(
      "cver",
      innertubeClient?.clientVersion ?? ytconfig.INNERTUBE_CLIENT_VERSION,
    );
    deviceParams.set("cplayer", "UNIPLAYER");

    return deviceParams.toString();
  }

  static getSubtitles(userLang: string) {
    const response = YoutubeHelper.getPlayerResponse();
    const playerCaptions = response?.captions?.playerCaptionsTracklistRenderer;
    if (!playerCaptions) {
      return [];
    }

    const captionTracks = playerCaptions.captionTracks ?? [];
    const translationLanguages = playerCaptions.translationLanguages ?? [];
    const userLangSupported = translationLanguages.find(
      (language) => language.languageCode === userLang,
    );
    const asrSubtitleItem = captionTracks.find(
      (captionTrack) => captionTrack?.kind === "asr",
    );
    const asrLang = asrSubtitleItem?.languageCode ?? "en";

    const subtitles = captionTracks.reduce((result, captionTrack) => {
      if (!("languageCode" in captionTrack)) {
        return result;
      }

      const language = captionTrack.languageCode
        ? normalizeLang(captionTrack.languageCode)
        : undefined;
      const url = captionTrack.baseUrl;
      if (!language || !url) {
        return result;
      }

      const captionUrl = `${
        url.startsWith("http") ? url : `${window.location.origin}/${url}`
      }&fmt=json3`;
      result.push({
        source: "youtube",
        format: "json",
        language,
        isAutoGenerated: captionTrack?.kind === "asr",
        url: captionUrl,
      });

      if (
        userLangSupported &&
        captionTrack.isTranslatable &&
        captionTrack.languageCode === asrLang &&
        userLang !== language
      ) {
        // add translated youtube subtitles (if it possible)
        result.push({
          source: "youtube",
          format: "json",
          language: userLang,
          isAutoGenerated: captionTrack?.kind === "asr",
          translatedFromLanguage: language,
          url: `${captionUrl}&tlang=${userLang}`,
        });
      }

      return result;
    }, [] as VideoDataSubtitle[]);
    Logger.log("youtube subtitles:", subtitles);
    return subtitles;
  }

  static getLanguage() {
    if (!YoutubeHelper.isMobile()) {
      // get language from selected audio track if available
      const player = YoutubeHelper.getPlayer();
      const trackInfo = player?.getAudioTrack
        ?.call(undefined)
        ?.getLanguageInfo();
      if (trackInfo && trackInfo.id !== "und") {
        return normalizeLang(trackInfo.id.split(".")[0]);
      }
    }

    const response = YoutubeHelper.getPlayerResponse();
    const autoCaption =
      response?.captions?.playerCaptionsTracklistRenderer.captionTracks.find(
        (caption) => caption.kind === "asr" && caption.languageCode,
      );

    return autoCaption ? normalizeLang(autoCaption.languageCode) : undefined;
  }

  // eslint-disable-next-line @typescript-eslint/require-await
  async getVideoData(videoId: string): Promise<MinimalVideoData | undefined> {
    const { title: localizedTitle } = YoutubeHelper.getPlayerData() ?? {};
    const {
      shortDescription: description,
      isLive: isStream,
      title,
    } = YoutubeHelper.getPlayerResponse()?.videoDetails ?? {};
    const subtitles = YoutubeHelper.getSubtitles(this.language);
    let detectedLanguage = YoutubeHelper.getLanguage() as
      | RequestLang
      | undefined;
    if (detectedLanguage && !availableLangs.includes(detectedLanguage)) {
      detectedLanguage = undefined;
    }
    const duration =
      YoutubeHelper.getPlayer()?.getDuration?.call(undefined) ?? undefined;

    return {
      url: this.service!.url + videoId,
      isStream,
      title,
      localizedTitle,
      detectedLanguage,
      description,
      subtitles,
      duration,
    };
  }

  // eslint-disable-next-line @typescript-eslint/require-await
  async getVideoId(url: URL) {
    if (url.hostname === "youtu.be") {
      url.search = `?v=${url.pathname.replace("/", "")}`;
      url.pathname = "/watch";
    }

    if (url.searchParams.has("enablejsapi")) {
      const videoUrl = YoutubeHelper.getPlayer()?.getVideoUrl();
      url = videoUrl ? new URL(videoUrl) : url;
    }

    return (/(?:watch|embed|shorts|live)\/([^/]+)/.exec(url.pathname)?.[1] ??
      url.searchParams.get("v")) as string | undefined;
  }
}
