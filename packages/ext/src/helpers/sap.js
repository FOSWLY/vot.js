import { BaseHelper, VideoHelperError } from "./base";
import { normalizeLang } from "@vot.js/shared/utils/utils";
import Logger from "@vot.js/shared/utils/logger";
export default class SapHelper extends BaseHelper {
  API_ORIGIN = "https://learning.sap.com/";
  async requestKaltura(kalturaDomain, partnerId, entryId) {
    const clientTag = "html5:v3.17.22";
    const apiVersion = "3.3.0";
    try {
      const res = await this.fetch(
        `https://${kalturaDomain}/api_v3/service/multirequest`,
        {
          method: "POST",
          body: JSON.stringify({
            1: {
              service: "session",
              action: "startWidgetSession",
              widgetId: `_${partnerId}`,
            },
            2: {
              service: "baseEntry",
              action: "list",
              ks: "{1:result:ks}",
              filter: { redirectFromEntryId: entryId },
              responseProfile: {
                type: 1,
                fields:
                  "id,referenceId,name,description,dataUrl,duration,flavorParamsIds,type,dvrStatus,externalSourceType,createdAt,updatedAt,endDate,plays,views,downloadUrl,creatorId",
              },
            },
            3: {
              service: "baseEntry",
              action: "getPlaybackContext",
              entryId: "{2:result:objects:0:id}",
              ks: "{1:result:ks}",
              contextDataParams: {
                objectType: "KalturaContextDataParams",
                flavorTags: "all",
              },
            },
            apiVersion,
            format: 1,
            ks: "",
            clientTag,
            partnerId,
          }),
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
      return await res.json();
    } catch (err) {
      Logger.error("Failed to request kaltura data", err.message);
      return undefined;
    }
  }
  async getKalturaData(videoId) {
    try {
      const scriptEl = document.querySelector(
        'script[data-nscript="beforeInteractive"]',
      );
      if (!scriptEl) {
        throw new VideoHelperError("Failed to find script element");
      }
      const sapData =
        /https:\/\/([^"]+)\/p\/([^"]+)\/embedPlaykitJs\/uiconf_id\/([^"]+)/.exec(
          scriptEl?.src,
        );
      if (!sapData) {
        throw new VideoHelperError(
          `Failed to get sap data for videoId: ${videoId}`,
        );
      }
      const [, kalturaDomain, partnerId] = sapData;
      let entryId = document
        .querySelector("#shadow")
        ?.firstChild?.getAttribute("id");
      if (!entryId) {
        const nextDataEl = document.querySelector("#__NEXT_DATA__");
        if (!nextDataEl) {
          throw new VideoHelperError("Failed to find next data element");
        }
        entryId = /"sourceId":\s?"([^"]+)"/.exec(nextDataEl.innerText)?.[1];
      }
      if (!kalturaDomain || Number.isNaN(+partnerId) || !entryId) {
        throw new VideoHelperError(
          `One of the necessary parameters for getting a link to a sap video in wasn't found for ${videoId}. Params: kalturaDomain = ${kalturaDomain}, partnerId = ${partnerId}, entryId = ${entryId}`,
        );
      }
      return await this.requestKaltura(kalturaDomain, partnerId, entryId);
    } catch (err) {
      Logger.error("Failed to get kaltura data", err.message);
      return undefined;
    }
  }
  async getVideoData(videoId) {
    const kalturaData = await this.getKalturaData(videoId);
    if (!kalturaData) {
      return undefined;
    }
    const [, baseEntryList, playbackContext] = kalturaData;
    const { duration } = baseEntryList.objects[0];
    const videoUrl = playbackContext.sources.find(
      (source) =>
        source.format === "url" &&
        source.protocols === "http,https" &&
        source.url.includes(".mp4"),
    )?.url;
    if (!videoUrl) {
      return undefined;
    }
    const subtitles = playbackContext.playbackCaptions.map((caption) => {
      return {
        language: normalizeLang(caption.languageCode),
        format: "vtt",
        url: caption.webVttUrl,
        isAutoGenerated: caption.label.includes("auto-generated"),
      };
    });
    return {
      url: videoUrl,
      subtitles,
      duration,
    };
  }
  async getVideoId(url) {
    return /((courses|learning-journeys)\/([^/]+)(\/[^/]+)?)/.exec(
      url.pathname,
    )?.[1];
  }
}
