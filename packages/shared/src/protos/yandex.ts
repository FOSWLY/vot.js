// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.15.8
// source: src/protos/yandex.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export enum StreamInterval {
  NO_CONNECTION = 0,
  TRANSLATING = 10,
  STREAMING = 20,
  UNRECOGNIZED = -1,
}

export function streamIntervalFromJSON(object: any): StreamInterval {
  switch (object) {
    case 0:
    case "NO_CONNECTION":
      return StreamInterval.NO_CONNECTION;
    case 10:
    case "TRANSLATING":
      return StreamInterval.TRANSLATING;
    case 20:
    case "STREAMING":
      return StreamInterval.STREAMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamInterval.UNRECOGNIZED;
  }
}

export function streamIntervalToJSON(object: StreamInterval): string {
  switch (object) {
    case StreamInterval.NO_CONNECTION:
      return "NO_CONNECTION";
    case StreamInterval.TRANSLATING:
      return "TRANSLATING";
    case StreamInterval.STREAMING:
      return "STREAMING";
    case StreamInterval.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** VIDEO TRANSLATION */
export interface VideoTranslationHelpObject {
  /** video_file_url or subtitles_file_url */
  target: string;
  /** raw url to video file or subs */
  targetUrl: string;
}

export interface VideoTranslationRequest {
  url: string;
  /** used in mobile version */
  deviceId?: string | undefined;
  /** true for the first request, false for subsequent ones */
  firstRequest: boolean;
  duration: number;
  /** 1 1 */
  unknown0: number;
  /** source language code */
  language: string;
  /**
   * 0 - auto detected by yabrowser, 1 - user set his
   * (own lang by dropdown)
   */
  forceSourceLang: boolean;
  /** 0 0 */
  unknown1: number;
  /**
   * array for translation assistance
   * ([0] -> {2: link to video, 1: "video_file_url"},
   * [1] -> {2: link to subtitles, 1: "subtitles_file_url"})
   */
  translationHelp: VideoTranslationHelpObject[];
  responseLanguage: string;
  /** previously it was 0, now it is 1 */
  unknown2: number;
  /** 1 */
  unknown3: number;
  /**
   * they have some kind of limiter on requests from one IP
   * because after one such request it stops working
   */
  bypassCache: boolean;
  /**
   * translates videos with higher-quality voices, but sometimes the
   * voice of one person can constantly change
   * (https://github.com/ilyhalight/voice-over-translation/issues/897)
   */
  useNewModel: boolean;
}

export interface VideoTranslationResponse {
  /** this 2 options set if status is translated */
  url?: string | undefined;
  duration?: number | undefined;
  status: number;
  /** secs until translation is completed */
  remainingTime?: number | undefined;
  /**
   * unknown 0 (1st request) ->
   * 10 (2nd, 3th and etc requests). (if status is 0)
   */
  unknown0?: number | undefined;
  /** it isn't a type mistake */
  translationId: string;
  /** detected language (if the wrong one is set) */
  language?: string | undefined;
  message?: string | undefined;
}

/**
 * video translation audio info (can be part of ChunkAudioObject or used
 * separated)
 */
export interface AudioBufferObject {
  /**
   * e.g:
   * 32Eߣ�B��01B��01B�04B�10B��webmB��04B��0230S�g010000000033��21M�t�M��S��25I�fS��00000000000000DM��S��26T�kS��0000000000000077M��S��34S�kS��00000000000000�25I�f�*ױ�17B@D��Gш�M��google/video-fileWA�google/video-file26T�k֮�ׁ01sŇ\����ϡ��02��00"���eng��A_OPUSc��OpusHead0105E�37�fSց�0�23�p�C\�ws�ܔ��00q]�77_�mt�26+.�y�$��31�00���J=33�34�iw�16�02�4�L�21U��30)`00000000,A+�Hv9��?C��05����º�31��
   * ���f�L01�36w�n_35kJ�������Q�g�}5 3126,�͋���)�[z�8��H+31�vvX�.f��)
   * also can be empty if it's failed audio js
   */
  audioFile: Uint8Array;
  /**
   * if it's single file u set json data
   * {"downloadType":"web_api_get_all_generating_urls_data_from_iframe","itag":251,"minChunkSize":5295308,"fileSize":"xxx"}
   * if it's chunk u set chunk index (0-xxx...)
   * if it's error u set only downloadType
   * (1=web_api_get_all_generating_urls_data_from_iframe)
   */
  fileId: string;
}

/** video translation audio info */
export interface ChunkAudioObject {
  /** 1-xxx... */
  audioPartsLength: number;
  audioBuffer: AudioBufferObject | undefined;
  /**
   * I don't know why it's a fileId, but they call it that
   * {"downloadType":"web_api_get_all_generating_urls_data_from_iframe","itag":251,"minChunkSize":5295308,"fileSize":"xxxx"}
   */
  fileId: string;
  /**
   * There are several possible assignments:
   * - version: is static 1
   * - purpose: is enum (1 = video-translation)
   * - fromPlayer: is boolean
   */
  unknown0: number;
}

/** can have only partialAudioInfo or only audioInfo */
export interface VideoTranslationAudioRequest {
  translationId: string;
  url: string;
  partialAudioInfo?: ChunkAudioObject | undefined;
  audioInfo?: AudioBufferObject | undefined;
}

export interface VideoTranslationAudioResponse {
  /**
   * something like this
   * 1 = waiting chunks
   * 2 = done
   */
  status: number;
  remainingChunks: string[];
}

/** SUBTITLES */
export interface SubtitlesObject {
  language: string;
  url: string;
  unknown0: number;
  translatedLanguage: string;
  translatedUrl: string;
  unknown1: number;
  unknown2: number;
}

export interface SubtitlesRequest {
  url: string;
  /** source language code */
  language: string;
}

export interface SubtitlesResponse {
  /** 0 - finished/failed, 1 - waiting result (1 - ~10min, maybe more) */
  waiting: boolean;
  subtitles: SubtitlesObject[];
}

/** STREAM TRANSLATION */
export interface StreamTranslationObject {
  url: string;
  /**
   * timestamp in ms (timing of m3u8).
   * it could have been int64,
   * but js requires an additional dependencies for this
   */
  timestamp: string;
}

export interface StreamTranslationRequest {
  url: string;
  language: string;
  responseLanguage: string;
}

export interface StreamTranslationResponse {
  /**
   * 20s - streaming, 10s - translating,
   * 0s - there is no connection with the server (the broadcast is finished or
   * deleted)
   */
  interval: StreamInterval;
  translatedInfo?: StreamTranslationObject | undefined;
  pingId?: number | undefined;
}

/** doesn't have response proto */
export interface StreamPingRequest {
  pingId: number;
}

/** SESSIONS */
export interface YandexSessionRequest {
  uuid: string;
  /** e.g. video_translation or summarization */
  module: string;
}

export interface YandexSessionResponse {
  secretKey: string;
  expires: number;
}

function createBaseVideoTranslationHelpObject(): VideoTranslationHelpObject {
  return { target: "", targetUrl: "" };
}

export const VideoTranslationHelpObject = {
  encode(
    message: VideoTranslationHelpObject,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.targetUrl !== "") {
      writer.uint32(18).string(message.targetUrl);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): VideoTranslationHelpObject {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationHelpObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationHelpObject {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      targetUrl: isSet(object.targetUrl)
        ? globalThis.String(object.targetUrl)
        : "",
    };
  },

  toJSON(message: VideoTranslationHelpObject): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.targetUrl !== "") {
      obj.targetUrl = message.targetUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationHelpObject>, I>>(
    base?: I,
  ): VideoTranslationHelpObject {
    return VideoTranslationHelpObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationHelpObject>, I>>(
    object: I,
  ): VideoTranslationHelpObject {
    const message = createBaseVideoTranslationHelpObject();
    message.target = object.target ?? "";
    message.targetUrl = object.targetUrl ?? "";
    return message;
  },
};

function createBaseVideoTranslationRequest(): VideoTranslationRequest {
  return {
    url: "",
    deviceId: undefined,
    firstRequest: false,
    duration: 0,
    unknown0: 0,
    language: "",
    forceSourceLang: false,
    unknown1: 0,
    translationHelp: [],
    responseLanguage: "",
    unknown2: 0,
    unknown3: 0,
    bypassCache: false,
    useNewModel: false,
  };
}

export const VideoTranslationRequest = {
  encode(
    message: VideoTranslationRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.deviceId !== undefined) {
      writer.uint32(34).string(message.deviceId);
    }
    if (message.firstRequest !== false) {
      writer.uint32(40).bool(message.firstRequest);
    }
    if (message.duration !== 0) {
      writer.uint32(49).double(message.duration);
    }
    if (message.unknown0 !== 0) {
      writer.uint32(56).int32(message.unknown0);
    }
    if (message.language !== "") {
      writer.uint32(66).string(message.language);
    }
    if (message.forceSourceLang !== false) {
      writer.uint32(72).bool(message.forceSourceLang);
    }
    if (message.unknown1 !== 0) {
      writer.uint32(80).int32(message.unknown1);
    }
    for (const v of message.translationHelp) {
      VideoTranslationHelpObject.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.responseLanguage !== "") {
      writer.uint32(114).string(message.responseLanguage);
    }
    if (message.unknown2 !== 0) {
      writer.uint32(120).int32(message.unknown2);
    }
    if (message.unknown3 !== 0) {
      writer.uint32(128).int32(message.unknown3);
    }
    if (message.bypassCache !== false) {
      writer.uint32(136).bool(message.bypassCache);
    }
    if (message.useNewModel !== false) {
      writer.uint32(144).bool(message.useNewModel);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): VideoTranslationRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.firstRequest = reader.bool();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.duration = reader.double();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.unknown0 = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.language = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.forceSourceLang = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.unknown1 = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.translationHelp.push(
            VideoTranslationHelpObject.decode(reader, reader.uint32()),
          );
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.responseLanguage = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.unknown2 = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.unknown3 = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.bypassCache = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.useNewModel = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      deviceId: isSet(object.deviceId)
        ? globalThis.String(object.deviceId)
        : undefined,
      firstRequest: isSet(object.firstRequest)
        ? globalThis.Boolean(object.firstRequest)
        : false,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      unknown0: isSet(object.unknown0) ? globalThis.Number(object.unknown0) : 0,
      language: isSet(object.language)
        ? globalThis.String(object.language)
        : "",
      forceSourceLang: isSet(object.forceSourceLang)
        ? globalThis.Boolean(object.forceSourceLang)
        : false,
      unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0,
      translationHelp: globalThis.Array.isArray(object?.translationHelp)
        ? object.translationHelp.map((e: any) =>
            VideoTranslationHelpObject.fromJSON(e),
          )
        : [],
      responseLanguage: isSet(object.responseLanguage)
        ? globalThis.String(object.responseLanguage)
        : "",
      unknown2: isSet(object.unknown2) ? globalThis.Number(object.unknown2) : 0,
      unknown3: isSet(object.unknown3) ? globalThis.Number(object.unknown3) : 0,
      bypassCache: isSet(object.bypassCache)
        ? globalThis.Boolean(object.bypassCache)
        : false,
      useNewModel: isSet(object.useNewModel)
        ? globalThis.Boolean(object.useNewModel)
        : false,
    };
  },

  toJSON(message: VideoTranslationRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.deviceId !== undefined) {
      obj.deviceId = message.deviceId;
    }
    if (message.firstRequest !== false) {
      obj.firstRequest = message.firstRequest;
    }
    if (message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.unknown0 !== 0) {
      obj.unknown0 = Math.round(message.unknown0);
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.forceSourceLang !== false) {
      obj.forceSourceLang = message.forceSourceLang;
    }
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    if (message.translationHelp?.length) {
      obj.translationHelp = message.translationHelp.map((e) =>
        VideoTranslationHelpObject.toJSON(e),
      );
    }
    if (message.responseLanguage !== "") {
      obj.responseLanguage = message.responseLanguage;
    }
    if (message.unknown2 !== 0) {
      obj.unknown2 = Math.round(message.unknown2);
    }
    if (message.unknown3 !== 0) {
      obj.unknown3 = Math.round(message.unknown3);
    }
    if (message.bypassCache !== false) {
      obj.bypassCache = message.bypassCache;
    }
    if (message.useNewModel !== false) {
      obj.useNewModel = message.useNewModel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationRequest>, I>>(
    base?: I,
  ): VideoTranslationRequest {
    return VideoTranslationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationRequest>, I>>(
    object: I,
  ): VideoTranslationRequest {
    const message = createBaseVideoTranslationRequest();
    message.url = object.url ?? "";
    message.deviceId = object.deviceId ?? undefined;
    message.firstRequest = object.firstRequest ?? false;
    message.duration = object.duration ?? 0;
    message.unknown0 = object.unknown0 ?? 0;
    message.language = object.language ?? "";
    message.forceSourceLang = object.forceSourceLang ?? false;
    message.unknown1 = object.unknown1 ?? 0;
    message.translationHelp =
      object.translationHelp?.map((e) =>
        VideoTranslationHelpObject.fromPartial(e),
      ) || [];
    message.responseLanguage = object.responseLanguage ?? "";
    message.unknown2 = object.unknown2 ?? 0;
    message.unknown3 = object.unknown3 ?? 0;
    message.bypassCache = object.bypassCache ?? false;
    message.useNewModel = object.useNewModel ?? false;
    return message;
  },
};

function createBaseVideoTranslationResponse(): VideoTranslationResponse {
  return {
    url: undefined,
    duration: undefined,
    status: 0,
    remainingTime: undefined,
    unknown0: undefined,
    translationId: "",
    language: undefined,
    message: undefined,
  };
}

export const VideoTranslationResponse = {
  encode(
    message: VideoTranslationResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.url !== undefined) {
      writer.uint32(10).string(message.url);
    }
    if (message.duration !== undefined) {
      writer.uint32(17).double(message.duration);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.remainingTime !== undefined) {
      writer.uint32(40).int32(message.remainingTime);
    }
    if (message.unknown0 !== undefined) {
      writer.uint32(48).int32(message.unknown0);
    }
    if (message.translationId !== "") {
      writer.uint32(58).string(message.translationId);
    }
    if (message.language !== undefined) {
      writer.uint32(66).string(message.language);
    }
    if (message.message !== undefined) {
      writer.uint32(74).string(message.message);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): VideoTranslationResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.duration = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.remainingTime = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.unknown0 = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.translationId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.language = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationResponse {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      duration: isSet(object.duration)
        ? globalThis.Number(object.duration)
        : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      remainingTime: isSet(object.remainingTime)
        ? globalThis.Number(object.remainingTime)
        : undefined,
      unknown0: isSet(object.unknown0)
        ? globalThis.Number(object.unknown0)
        : undefined,
      translationId: isSet(object.translationId)
        ? globalThis.String(object.translationId)
        : "",
      language: isSet(object.language)
        ? globalThis.String(object.language)
        : undefined,
      message: isSet(object.message)
        ? globalThis.String(object.message)
        : undefined,
    };
  },

  toJSON(message: VideoTranslationResponse): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.duration !== undefined) {
      obj.duration = message.duration;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.remainingTime !== undefined) {
      obj.remainingTime = Math.round(message.remainingTime);
    }
    if (message.unknown0 !== undefined) {
      obj.unknown0 = Math.round(message.unknown0);
    }
    if (message.translationId !== "") {
      obj.translationId = message.translationId;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationResponse>, I>>(
    base?: I,
  ): VideoTranslationResponse {
    return VideoTranslationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationResponse>, I>>(
    object: I,
  ): VideoTranslationResponse {
    const message = createBaseVideoTranslationResponse();
    message.url = object.url ?? undefined;
    message.duration = object.duration ?? undefined;
    message.status = object.status ?? 0;
    message.remainingTime = object.remainingTime ?? undefined;
    message.unknown0 = object.unknown0 ?? undefined;
    message.translationId = object.translationId ?? "";
    message.language = object.language ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseAudioBufferObject(): AudioBufferObject {
  return { audioFile: new Uint8Array(0), fileId: "" };
}

export const AudioBufferObject = {
  encode(
    message: AudioBufferObject,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.audioFile.length !== 0) {
      writer.uint32(18).bytes(message.audioFile);
    }
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AudioBufferObject {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioBufferObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioFile = reader.bytes();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioBufferObject {
    return {
      audioFile: isSet(object.audioFile)
        ? bytesFromBase64(object.audioFile)
        : new Uint8Array(0),
      fileId: isSet(object.fileId) ? globalThis.String(object.fileId) : "",
    };
  },

  toJSON(message: AudioBufferObject): unknown {
    const obj: any = {};
    if (message.audioFile.length !== 0) {
      obj.audioFile = base64FromBytes(message.audioFile);
    }
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioBufferObject>, I>>(
    base?: I,
  ): AudioBufferObject {
    return AudioBufferObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioBufferObject>, I>>(
    object: I,
  ): AudioBufferObject {
    const message = createBaseAudioBufferObject();
    message.audioFile = object.audioFile ?? new Uint8Array(0);
    message.fileId = object.fileId ?? "";
    return message;
  },
};

function createBaseChunkAudioObject(): ChunkAudioObject {
  return {
    audioPartsLength: 0,
    audioBuffer: undefined,
    fileId: "",
    unknown0: 0,
  };
}

export const ChunkAudioObject = {
  encode(
    message: ChunkAudioObject,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.audioPartsLength !== 0) {
      writer.uint32(16).int32(message.audioPartsLength);
    }
    if (message.audioBuffer !== undefined) {
      AudioBufferObject.encode(
        message.audioBuffer,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    if (message.fileId !== "") {
      writer.uint32(26).string(message.fileId);
    }
    if (message.unknown0 !== 0) {
      writer.uint32(32).int32(message.unknown0);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChunkAudioObject {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkAudioObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.audioPartsLength = reader.int32();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audioBuffer = AudioBufferObject.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fileId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.unknown0 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkAudioObject {
    return {
      audioPartsLength: isSet(object.audioPartsLength)
        ? globalThis.Number(object.audioPartsLength)
        : 0,
      audioBuffer: isSet(object.audioBuffer)
        ? AudioBufferObject.fromJSON(object.audioBuffer)
        : undefined,
      fileId: isSet(object.fileId) ? globalThis.String(object.fileId) : "",
      unknown0: isSet(object.unknown0) ? globalThis.Number(object.unknown0) : 0,
    };
  },

  toJSON(message: ChunkAudioObject): unknown {
    const obj: any = {};
    if (message.audioPartsLength !== 0) {
      obj.audioPartsLength = Math.round(message.audioPartsLength);
    }
    if (message.audioBuffer !== undefined) {
      obj.audioBuffer = AudioBufferObject.toJSON(message.audioBuffer);
    }
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.unknown0 !== 0) {
      obj.unknown0 = Math.round(message.unknown0);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChunkAudioObject>, I>>(
    base?: I,
  ): ChunkAudioObject {
    return ChunkAudioObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChunkAudioObject>, I>>(
    object: I,
  ): ChunkAudioObject {
    const message = createBaseChunkAudioObject();
    message.audioPartsLength = object.audioPartsLength ?? 0;
    message.audioBuffer =
      object.audioBuffer !== undefined && object.audioBuffer !== null
        ? AudioBufferObject.fromPartial(object.audioBuffer)
        : undefined;
    message.fileId = object.fileId ?? "";
    message.unknown0 = object.unknown0 ?? 0;
    return message;
  },
};

function createBaseVideoTranslationAudioRequest(): VideoTranslationAudioRequest {
  return {
    translationId: "",
    url: "",
    partialAudioInfo: undefined,
    audioInfo: undefined,
  };
}

export const VideoTranslationAudioRequest = {
  encode(
    message: VideoTranslationAudioRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.translationId !== "") {
      writer.uint32(10).string(message.translationId);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.partialAudioInfo !== undefined) {
      ChunkAudioObject.encode(
        message.partialAudioInfo,
        writer.uint32(34).fork(),
      ).ldelim();
    }
    if (message.audioInfo !== undefined) {
      AudioBufferObject.encode(
        message.audioInfo,
        writer.uint32(50).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): VideoTranslationAudioRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationAudioRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.translationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.partialAudioInfo = ChunkAudioObject.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.audioInfo = AudioBufferObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationAudioRequest {
    return {
      translationId: isSet(object.translationId)
        ? globalThis.String(object.translationId)
        : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      partialAudioInfo: isSet(object.partialAudioInfo)
        ? ChunkAudioObject.fromJSON(object.partialAudioInfo)
        : undefined,
      audioInfo: isSet(object.audioInfo)
        ? AudioBufferObject.fromJSON(object.audioInfo)
        : undefined,
    };
  },

  toJSON(message: VideoTranslationAudioRequest): unknown {
    const obj: any = {};
    if (message.translationId !== "") {
      obj.translationId = message.translationId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.partialAudioInfo !== undefined) {
      obj.partialAudioInfo = ChunkAudioObject.toJSON(message.partialAudioInfo);
    }
    if (message.audioInfo !== undefined) {
      obj.audioInfo = AudioBufferObject.toJSON(message.audioInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationAudioRequest>, I>>(
    base?: I,
  ): VideoTranslationAudioRequest {
    return VideoTranslationAudioRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationAudioRequest>, I>>(
    object: I,
  ): VideoTranslationAudioRequest {
    const message = createBaseVideoTranslationAudioRequest();
    message.translationId = object.translationId ?? "";
    message.url = object.url ?? "";
    message.partialAudioInfo =
      object.partialAudioInfo !== undefined && object.partialAudioInfo !== null
        ? ChunkAudioObject.fromPartial(object.partialAudioInfo)
        : undefined;
    message.audioInfo =
      object.audioInfo !== undefined && object.audioInfo !== null
        ? AudioBufferObject.fromPartial(object.audioInfo)
        : undefined;
    return message;
  },
};

function createBaseVideoTranslationAudioResponse(): VideoTranslationAudioResponse {
  return { status: 0, remainingChunks: [] };
}

export const VideoTranslationAudioResponse = {
  encode(
    message: VideoTranslationAudioResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.remainingChunks) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): VideoTranslationAudioResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationAudioResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remainingChunks.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationAudioResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      remainingChunks: globalThis.Array.isArray(object?.remainingChunks)
        ? object.remainingChunks.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: VideoTranslationAudioResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.remainingChunks?.length) {
      obj.remainingChunks = message.remainingChunks;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationAudioResponse>, I>>(
    base?: I,
  ): VideoTranslationAudioResponse {
    return VideoTranslationAudioResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationAudioResponse>, I>>(
    object: I,
  ): VideoTranslationAudioResponse {
    const message = createBaseVideoTranslationAudioResponse();
    message.status = object.status ?? 0;
    message.remainingChunks = object.remainingChunks?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubtitlesObject(): SubtitlesObject {
  return {
    language: "",
    url: "",
    unknown0: 0,
    translatedLanguage: "",
    translatedUrl: "",
    unknown1: 0,
    unknown2: 0,
  };
}

export const SubtitlesObject = {
  encode(
    message: SubtitlesObject,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.unknown0 !== 0) {
      writer.uint32(24).int32(message.unknown0);
    }
    if (message.translatedLanguage !== "") {
      writer.uint32(34).string(message.translatedLanguage);
    }
    if (message.translatedUrl !== "") {
      writer.uint32(42).string(message.translatedUrl);
    }
    if (message.unknown1 !== 0) {
      writer.uint32(48).int32(message.unknown1);
    }
    if (message.unknown2 !== 0) {
      writer.uint32(56).int32(message.unknown2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtitlesObject {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtitlesObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.unknown0 = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.translatedLanguage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.translatedUrl = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.unknown1 = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.unknown2 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtitlesObject {
    return {
      language: isSet(object.language)
        ? globalThis.String(object.language)
        : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      unknown0: isSet(object.unknown0) ? globalThis.Number(object.unknown0) : 0,
      translatedLanguage: isSet(object.translatedLanguage)
        ? globalThis.String(object.translatedLanguage)
        : "",
      translatedUrl: isSet(object.translatedUrl)
        ? globalThis.String(object.translatedUrl)
        : "",
      unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0,
      unknown2: isSet(object.unknown2) ? globalThis.Number(object.unknown2) : 0,
    };
  },

  toJSON(message: SubtitlesObject): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.unknown0 !== 0) {
      obj.unknown0 = Math.round(message.unknown0);
    }
    if (message.translatedLanguage !== "") {
      obj.translatedLanguage = message.translatedLanguage;
    }
    if (message.translatedUrl !== "") {
      obj.translatedUrl = message.translatedUrl;
    }
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    if (message.unknown2 !== 0) {
      obj.unknown2 = Math.round(message.unknown2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubtitlesObject>, I>>(
    base?: I,
  ): SubtitlesObject {
    return SubtitlesObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubtitlesObject>, I>>(
    object: I,
  ): SubtitlesObject {
    const message = createBaseSubtitlesObject();
    message.language = object.language ?? "";
    message.url = object.url ?? "";
    message.unknown0 = object.unknown0 ?? 0;
    message.translatedLanguage = object.translatedLanguage ?? "";
    message.translatedUrl = object.translatedUrl ?? "";
    message.unknown1 = object.unknown1 ?? 0;
    message.unknown2 = object.unknown2 ?? 0;
    return message;
  },
};

function createBaseSubtitlesRequest(): SubtitlesRequest {
  return { url: "", language: "" };
}

export const SubtitlesRequest = {
  encode(
    message: SubtitlesRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtitlesRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtitlesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtitlesRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      language: isSet(object.language)
        ? globalThis.String(object.language)
        : "",
    };
  },

  toJSON(message: SubtitlesRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubtitlesRequest>, I>>(
    base?: I,
  ): SubtitlesRequest {
    return SubtitlesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubtitlesRequest>, I>>(
    object: I,
  ): SubtitlesRequest {
    const message = createBaseSubtitlesRequest();
    message.url = object.url ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseSubtitlesResponse(): SubtitlesResponse {
  return { waiting: false, subtitles: [] };
}

export const SubtitlesResponse = {
  encode(
    message: SubtitlesResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.waiting !== false) {
      writer.uint32(8).bool(message.waiting);
    }
    for (const v of message.subtitles) {
      SubtitlesObject.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtitlesResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtitlesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.waiting = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subtitles.push(
            SubtitlesObject.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtitlesResponse {
    return {
      waiting: isSet(object.waiting)
        ? globalThis.Boolean(object.waiting)
        : false,
      subtitles: globalThis.Array.isArray(object?.subtitles)
        ? object.subtitles.map((e: any) => SubtitlesObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubtitlesResponse): unknown {
    const obj: any = {};
    if (message.waiting !== false) {
      obj.waiting = message.waiting;
    }
    if (message.subtitles?.length) {
      obj.subtitles = message.subtitles.map((e) => SubtitlesObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubtitlesResponse>, I>>(
    base?: I,
  ): SubtitlesResponse {
    return SubtitlesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubtitlesResponse>, I>>(
    object: I,
  ): SubtitlesResponse {
    const message = createBaseSubtitlesResponse();
    message.waiting = object.waiting ?? false;
    message.subtitles =
      object.subtitles?.map((e) => SubtitlesObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamTranslationObject(): StreamTranslationObject {
  return { url: "", timestamp: "" };
}

export const StreamTranslationObject = {
  encode(
    message: StreamTranslationObject,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): StreamTranslationObject {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTranslationObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTranslationObject {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      timestamp: isSet(object.timestamp)
        ? globalThis.String(object.timestamp)
        : "",
    };
  },

  toJSON(message: StreamTranslationObject): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamTranslationObject>, I>>(
    base?: I,
  ): StreamTranslationObject {
    return StreamTranslationObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamTranslationObject>, I>>(
    object: I,
  ): StreamTranslationObject {
    const message = createBaseStreamTranslationObject();
    message.url = object.url ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseStreamTranslationRequest(): StreamTranslationRequest {
  return { url: "", language: "", responseLanguage: "" };
}

export const StreamTranslationRequest = {
  encode(
    message: StreamTranslationRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    if (message.responseLanguage !== "") {
      writer.uint32(26).string(message.responseLanguage);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): StreamTranslationRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTranslationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseLanguage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTranslationRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      language: isSet(object.language)
        ? globalThis.String(object.language)
        : "",
      responseLanguage: isSet(object.responseLanguage)
        ? globalThis.String(object.responseLanguage)
        : "",
    };
  },

  toJSON(message: StreamTranslationRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.responseLanguage !== "") {
      obj.responseLanguage = message.responseLanguage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamTranslationRequest>, I>>(
    base?: I,
  ): StreamTranslationRequest {
    return StreamTranslationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamTranslationRequest>, I>>(
    object: I,
  ): StreamTranslationRequest {
    const message = createBaseStreamTranslationRequest();
    message.url = object.url ?? "";
    message.language = object.language ?? "";
    message.responseLanguage = object.responseLanguage ?? "";
    return message;
  },
};

function createBaseStreamTranslationResponse(): StreamTranslationResponse {
  return { interval: 0, translatedInfo: undefined, pingId: undefined };
}

export const StreamTranslationResponse = {
  encode(
    message: StreamTranslationResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.interval !== 0) {
      writer.uint32(8).int32(message.interval);
    }
    if (message.translatedInfo !== undefined) {
      StreamTranslationObject.encode(
        message.translatedInfo,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    if (message.pingId !== undefined) {
      writer.uint32(24).int32(message.pingId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): StreamTranslationResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTranslationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.translatedInfo = StreamTranslationObject.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pingId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTranslationResponse {
    return {
      interval: isSet(object.interval)
        ? streamIntervalFromJSON(object.interval)
        : 0,
      translatedInfo: isSet(object.translatedInfo)
        ? StreamTranslationObject.fromJSON(object.translatedInfo)
        : undefined,
      pingId: isSet(object.pingId)
        ? globalThis.Number(object.pingId)
        : undefined,
    };
  },

  toJSON(message: StreamTranslationResponse): unknown {
    const obj: any = {};
    if (message.interval !== 0) {
      obj.interval = streamIntervalToJSON(message.interval);
    }
    if (message.translatedInfo !== undefined) {
      obj.translatedInfo = StreamTranslationObject.toJSON(
        message.translatedInfo,
      );
    }
    if (message.pingId !== undefined) {
      obj.pingId = Math.round(message.pingId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamTranslationResponse>, I>>(
    base?: I,
  ): StreamTranslationResponse {
    return StreamTranslationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamTranslationResponse>, I>>(
    object: I,
  ): StreamTranslationResponse {
    const message = createBaseStreamTranslationResponse();
    message.interval = object.interval ?? 0;
    message.translatedInfo =
      object.translatedInfo !== undefined && object.translatedInfo !== null
        ? StreamTranslationObject.fromPartial(object.translatedInfo)
        : undefined;
    message.pingId = object.pingId ?? undefined;
    return message;
  },
};

function createBaseStreamPingRequest(): StreamPingRequest {
  return { pingId: 0 };
}

export const StreamPingRequest = {
  encode(
    message: StreamPingRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pingId !== 0) {
      writer.uint32(8).int32(message.pingId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamPingRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamPingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pingId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamPingRequest {
    return {
      pingId: isSet(object.pingId) ? globalThis.Number(object.pingId) : 0,
    };
  },

  toJSON(message: StreamPingRequest): unknown {
    const obj: any = {};
    if (message.pingId !== 0) {
      obj.pingId = Math.round(message.pingId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamPingRequest>, I>>(
    base?: I,
  ): StreamPingRequest {
    return StreamPingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamPingRequest>, I>>(
    object: I,
  ): StreamPingRequest {
    const message = createBaseStreamPingRequest();
    message.pingId = object.pingId ?? 0;
    return message;
  },
};

function createBaseYandexSessionRequest(): YandexSessionRequest {
  return { uuid: "", module: "" };
}

export const YandexSessionRequest = {
  encode(
    message: YandexSessionRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.module !== "") {
      writer.uint32(18).string(message.module);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): YandexSessionRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYandexSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.module = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YandexSessionRequest {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      module: isSet(object.module) ? globalThis.String(object.module) : "",
    };
  },

  toJSON(message: YandexSessionRequest): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.module !== "") {
      obj.module = message.module;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YandexSessionRequest>, I>>(
    base?: I,
  ): YandexSessionRequest {
    return YandexSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YandexSessionRequest>, I>>(
    object: I,
  ): YandexSessionRequest {
    const message = createBaseYandexSessionRequest();
    message.uuid = object.uuid ?? "";
    message.module = object.module ?? "";
    return message;
  },
};

function createBaseYandexSessionResponse(): YandexSessionResponse {
  return { secretKey: "", expires: 0 };
}

export const YandexSessionResponse = {
  encode(
    message: YandexSessionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.secretKey !== "") {
      writer.uint32(10).string(message.secretKey);
    }
    if (message.expires !== 0) {
      writer.uint32(16).int32(message.expires);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): YandexSessionResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYandexSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secretKey = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expires = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YandexSessionResponse {
    return {
      secretKey: isSet(object.secretKey)
        ? globalThis.String(object.secretKey)
        : "",
      expires: isSet(object.expires) ? globalThis.Number(object.expires) : 0,
    };
  },

  toJSON(message: YandexSessionResponse): unknown {
    const obj: any = {};
    if (message.secretKey !== "") {
      obj.secretKey = message.secretKey;
    }
    if (message.expires !== 0) {
      obj.expires = Math.round(message.expires);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YandexSessionResponse>, I>>(
    base?: I,
  ): YandexSessionResponse {
    return YandexSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YandexSessionResponse>, I>>(
    object: I,
  ): YandexSessionResponse {
    const message = createBaseYandexSessionResponse();
    message.secretKey = object.secretKey ?? "";
    message.expires = object.expires ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
