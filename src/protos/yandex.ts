// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.21.9
// source: src/protos/yandex.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export enum StreamInterval {
  NO_CONNECTION = 0,
  TRANSLATING = 10,
  STREAMING = 20,
  UNRECOGNIZED = -1,
}

export function streamIntervalFromJSON(object: any): StreamInterval {
  switch (object) {
    case 0:
    case "NO_CONNECTION":
      return StreamInterval.NO_CONNECTION;
    case 10:
    case "TRANSLATING":
      return StreamInterval.TRANSLATING;
    case 20:
    case "STREAMING":
      return StreamInterval.STREAMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamInterval.UNRECOGNIZED;
  }
}

export function streamIntervalToJSON(object: StreamInterval): string {
  switch (object) {
    case StreamInterval.NO_CONNECTION:
      return "NO_CONNECTION";
    case StreamInterval.TRANSLATING:
      return "TRANSLATING";
    case StreamInterval.STREAMING:
      return "STREAMING";
    case StreamInterval.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** VIDEO TRANSLATION */
export interface VideoTranslationHelpObject {
  /** video_file_url or subtitles_file_url */
  target: string;
  /** raw url to video file or subs */
  targetUrl: string;
}

export interface VideoTranslationRequest {
  url: string;
  /** used in mobile version */
  deviceId?:
    | string
    | undefined;
  /** true for the first request, false for subsequent ones */
  firstRequest: boolean;
  duration: number;
  /** 1 1 */
  unknown0: number;
  /** source language code */
  language: string;
  /** 0 - auto detected by yabrowser, 1 - user set his own lang by dropdown */
  forceSourceLang: boolean;
  /** 0 0 */
  unknown1: number;
  /** array for translation assistance ([0] -> {2: link to video, 1: "video_file_url"}, [1] -> {2: link to subtitles, 1: "subtitles_file_url"}) */
  translationHelp: VideoTranslationHelpObject[];
  responseLanguage: string;
  /** 0 */
  unknown2: number;
  /** 1 */
  unknown3: number;
  /** ? maybe they have some kind of bypass limiter from one IP, because after one such request it stopped working */
  bypassCache: boolean;
}

export interface VideoTranslationResponse {
  /** if status is translated */
  url?: string | undefined;
  duration?: number | undefined;
  status: number;
  /** secs until translation is completed */
  remainingTime?:
    | number
    | undefined;
  /** unknown 0 (1st request) -> 10 (2nd, 3th and etc requests). (if status is 0) */
  unknown0?:
    | number
    | undefined;
  /** it's not a type mistake */
  translationId: string;
  /** detected language (if the wrong one is set) */
  language?: string | undefined;
  message?: string | undefined;
}

/** SUBTITLES */
export interface SubtitlesObject {
  language: string;
  url: string;
  unknown0: number;
  translatedLanguages: string;
  translatedUrl: string;
  unknown1: number;
  unknown2: number;
}

export interface SubtitlesRequest {
  url: string;
  /** source language code */
  language: string;
}

export interface SubtitlesResponse {
  /** 0 - finished/failed, 1 - waiting result (1 - ~10min, maybe more) */
  waiting: boolean;
  subtitles: SubtitlesObject[];
}

/** STREAM TRANSLATION */
export interface StreamTranslationObject {
  url: string;
  /** timestamp in ms (timing of m3u8) */
  timestamp: number;
}

export interface StreamTranslationRequest {
  url: string;
  language: string;
  responseLanguage: string;
}

export interface StreamTranslationResponse {
  /** 20s - streaming, 10s - translating, 0s - there is no connection with the server (the broadcast is finished or deleted) */
  interval: StreamInterval;
  translatedInfo?: StreamTranslationObject | undefined;
  pingId?: number | undefined;
}

/** doesn't have response proto */
export interface StreamPingRequest {
  pingId: number;
}

/** SESSIONS */
export interface YandexSessionRequest {
  uuid: string;
  /** e.g. video_translation */
  module: string;
}

export interface YandexSessionResponse {
  sign: string;
  expires: number;
}

function createBaseVideoTranslationHelpObject(): VideoTranslationHelpObject {
  return { target: "", targetUrl: "" };
}

export const VideoTranslationHelpObject = {
  encode(message: VideoTranslationHelpObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.targetUrl !== "") {
      writer.uint32(18).string(message.targetUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VideoTranslationHelpObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationHelpObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationHelpObject {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      targetUrl: isSet(object.targetUrl) ? globalThis.String(object.targetUrl) : "",
    };
  },

  toJSON(message: VideoTranslationHelpObject): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.targetUrl !== "") {
      obj.targetUrl = message.targetUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationHelpObject>, I>>(base?: I): VideoTranslationHelpObject {
    return VideoTranslationHelpObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationHelpObject>, I>>(object: I): VideoTranslationHelpObject {
    const message = createBaseVideoTranslationHelpObject();
    message.target = object.target ?? "";
    message.targetUrl = object.targetUrl ?? "";
    return message;
  },
};

function createBaseVideoTranslationRequest(): VideoTranslationRequest {
  return {
    url: "",
    deviceId: undefined,
    firstRequest: false,
    duration: 0,
    unknown0: 0,
    language: "",
    forceSourceLang: false,
    unknown1: 0,
    translationHelp: [],
    responseLanguage: "",
    unknown2: 0,
    unknown3: 0,
    bypassCache: false,
  };
}

export const VideoTranslationRequest = {
  encode(message: VideoTranslationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.deviceId !== undefined) {
      writer.uint32(34).string(message.deviceId);
    }
    if (message.firstRequest !== false) {
      writer.uint32(40).bool(message.firstRequest);
    }
    if (message.duration !== 0) {
      writer.uint32(49).double(message.duration);
    }
    if (message.unknown0 !== 0) {
      writer.uint32(56).int32(message.unknown0);
    }
    if (message.language !== "") {
      writer.uint32(66).string(message.language);
    }
    if (message.forceSourceLang !== false) {
      writer.uint32(72).bool(message.forceSourceLang);
    }
    if (message.unknown1 !== 0) {
      writer.uint32(80).int32(message.unknown1);
    }
    for (const v of message.translationHelp) {
      VideoTranslationHelpObject.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.responseLanguage !== "") {
      writer.uint32(114).string(message.responseLanguage);
    }
    if (message.unknown2 !== 0) {
      writer.uint32(120).int32(message.unknown2);
    }
    if (message.unknown3 !== 0) {
      writer.uint32(128).int32(message.unknown3);
    }
    if (message.bypassCache !== false) {
      writer.uint32(136).bool(message.bypassCache);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VideoTranslationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.firstRequest = reader.bool();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.duration = reader.double();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.unknown0 = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.language = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.forceSourceLang = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.unknown1 = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.translationHelp.push(VideoTranslationHelpObject.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.responseLanguage = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.unknown2 = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.unknown3 = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.bypassCache = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : undefined,
      firstRequest: isSet(object.firstRequest) ? globalThis.Boolean(object.firstRequest) : false,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      unknown0: isSet(object.unknown0) ? globalThis.Number(object.unknown0) : 0,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      forceSourceLang: isSet(object.forceSourceLang) ? globalThis.Boolean(object.forceSourceLang) : false,
      unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0,
      translationHelp: globalThis.Array.isArray(object?.translationHelp)
        ? object.translationHelp.map((e: any) => VideoTranslationHelpObject.fromJSON(e))
        : [],
      responseLanguage: isSet(object.responseLanguage) ? globalThis.String(object.responseLanguage) : "",
      unknown2: isSet(object.unknown2) ? globalThis.Number(object.unknown2) : 0,
      unknown3: isSet(object.unknown3) ? globalThis.Number(object.unknown3) : 0,
      bypassCache: isSet(object.bypassCache) ? globalThis.Boolean(object.bypassCache) : false,
    };
  },

  toJSON(message: VideoTranslationRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.deviceId !== undefined) {
      obj.deviceId = message.deviceId;
    }
    if (message.firstRequest !== false) {
      obj.firstRequest = message.firstRequest;
    }
    if (message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.unknown0 !== 0) {
      obj.unknown0 = Math.round(message.unknown0);
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.forceSourceLang !== false) {
      obj.forceSourceLang = message.forceSourceLang;
    }
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    if (message.translationHelp?.length) {
      obj.translationHelp = message.translationHelp.map((e) => VideoTranslationHelpObject.toJSON(e));
    }
    if (message.responseLanguage !== "") {
      obj.responseLanguage = message.responseLanguage;
    }
    if (message.unknown2 !== 0) {
      obj.unknown2 = Math.round(message.unknown2);
    }
    if (message.unknown3 !== 0) {
      obj.unknown3 = Math.round(message.unknown3);
    }
    if (message.bypassCache !== false) {
      obj.bypassCache = message.bypassCache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationRequest>, I>>(base?: I): VideoTranslationRequest {
    return VideoTranslationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationRequest>, I>>(object: I): VideoTranslationRequest {
    const message = createBaseVideoTranslationRequest();
    message.url = object.url ?? "";
    message.deviceId = object.deviceId ?? undefined;
    message.firstRequest = object.firstRequest ?? false;
    message.duration = object.duration ?? 0;
    message.unknown0 = object.unknown0 ?? 0;
    message.language = object.language ?? "";
    message.forceSourceLang = object.forceSourceLang ?? false;
    message.unknown1 = object.unknown1 ?? 0;
    message.translationHelp = object.translationHelp?.map((e) => VideoTranslationHelpObject.fromPartial(e)) || [];
    message.responseLanguage = object.responseLanguage ?? "";
    message.unknown2 = object.unknown2 ?? 0;
    message.unknown3 = object.unknown3 ?? 0;
    message.bypassCache = object.bypassCache ?? false;
    return message;
  },
};

function createBaseVideoTranslationResponse(): VideoTranslationResponse {
  return {
    url: undefined,
    duration: undefined,
    status: 0,
    remainingTime: undefined,
    unknown0: undefined,
    translationId: "",
    language: undefined,
    message: undefined,
  };
}

export const VideoTranslationResponse = {
  encode(message: VideoTranslationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== undefined) {
      writer.uint32(10).string(message.url);
    }
    if (message.duration !== undefined) {
      writer.uint32(17).double(message.duration);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.remainingTime !== undefined) {
      writer.uint32(40).int32(message.remainingTime);
    }
    if (message.unknown0 !== undefined) {
      writer.uint32(48).int32(message.unknown0);
    }
    if (message.translationId !== "") {
      writer.uint32(58).string(message.translationId);
    }
    if (message.language !== undefined) {
      writer.uint32(66).string(message.language);
    }
    if (message.message !== undefined) {
      writer.uint32(74).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VideoTranslationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoTranslationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.duration = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.remainingTime = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.unknown0 = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.translationId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.language = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoTranslationResponse {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      remainingTime: isSet(object.remainingTime) ? globalThis.Number(object.remainingTime) : undefined,
      unknown0: isSet(object.unknown0) ? globalThis.Number(object.unknown0) : undefined,
      translationId: isSet(object.translationId) ? globalThis.String(object.translationId) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: VideoTranslationResponse): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.duration !== undefined) {
      obj.duration = message.duration;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.remainingTime !== undefined) {
      obj.remainingTime = Math.round(message.remainingTime);
    }
    if (message.unknown0 !== undefined) {
      obj.unknown0 = Math.round(message.unknown0);
    }
    if (message.translationId !== "") {
      obj.translationId = message.translationId;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoTranslationResponse>, I>>(base?: I): VideoTranslationResponse {
    return VideoTranslationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoTranslationResponse>, I>>(object: I): VideoTranslationResponse {
    const message = createBaseVideoTranslationResponse();
    message.url = object.url ?? undefined;
    message.duration = object.duration ?? undefined;
    message.status = object.status ?? 0;
    message.remainingTime = object.remainingTime ?? undefined;
    message.unknown0 = object.unknown0 ?? undefined;
    message.translationId = object.translationId ?? "";
    message.language = object.language ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseSubtitlesObject(): SubtitlesObject {
  return { language: "", url: "", unknown0: 0, translatedLanguages: "", translatedUrl: "", unknown1: 0, unknown2: 0 };
}

export const SubtitlesObject = {
  encode(message: SubtitlesObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.unknown0 !== 0) {
      writer.uint32(24).int32(message.unknown0);
    }
    if (message.translatedLanguages !== "") {
      writer.uint32(34).string(message.translatedLanguages);
    }
    if (message.translatedUrl !== "") {
      writer.uint32(42).string(message.translatedUrl);
    }
    if (message.unknown1 !== 0) {
      writer.uint32(48).int32(message.unknown1);
    }
    if (message.unknown2 !== 0) {
      writer.uint32(56).int32(message.unknown2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtitlesObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtitlesObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.unknown0 = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.translatedLanguages = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.translatedUrl = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.unknown1 = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.unknown2 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtitlesObject {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      unknown0: isSet(object.unknown0) ? globalThis.Number(object.unknown0) : 0,
      translatedLanguages: isSet(object.translatedLanguages) ? globalThis.String(object.translatedLanguages) : "",
      translatedUrl: isSet(object.translatedUrl) ? globalThis.String(object.translatedUrl) : "",
      unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0,
      unknown2: isSet(object.unknown2) ? globalThis.Number(object.unknown2) : 0,
    };
  },

  toJSON(message: SubtitlesObject): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.unknown0 !== 0) {
      obj.unknown0 = Math.round(message.unknown0);
    }
    if (message.translatedLanguages !== "") {
      obj.translatedLanguages = message.translatedLanguages;
    }
    if (message.translatedUrl !== "") {
      obj.translatedUrl = message.translatedUrl;
    }
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    if (message.unknown2 !== 0) {
      obj.unknown2 = Math.round(message.unknown2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubtitlesObject>, I>>(base?: I): SubtitlesObject {
    return SubtitlesObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubtitlesObject>, I>>(object: I): SubtitlesObject {
    const message = createBaseSubtitlesObject();
    message.language = object.language ?? "";
    message.url = object.url ?? "";
    message.unknown0 = object.unknown0 ?? 0;
    message.translatedLanguages = object.translatedLanguages ?? "";
    message.translatedUrl = object.translatedUrl ?? "";
    message.unknown1 = object.unknown1 ?? 0;
    message.unknown2 = object.unknown2 ?? 0;
    return message;
  },
};

function createBaseSubtitlesRequest(): SubtitlesRequest {
  return { url: "", language: "" };
}

export const SubtitlesRequest = {
  encode(message: SubtitlesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtitlesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtitlesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtitlesRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: SubtitlesRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubtitlesRequest>, I>>(base?: I): SubtitlesRequest {
    return SubtitlesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubtitlesRequest>, I>>(object: I): SubtitlesRequest {
    const message = createBaseSubtitlesRequest();
    message.url = object.url ?? "";
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseSubtitlesResponse(): SubtitlesResponse {
  return { waiting: false, subtitles: [] };
}

export const SubtitlesResponse = {
  encode(message: SubtitlesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.waiting !== false) {
      writer.uint32(8).bool(message.waiting);
    }
    for (const v of message.subtitles) {
      SubtitlesObject.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtitlesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtitlesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.waiting = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subtitles.push(SubtitlesObject.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtitlesResponse {
    return {
      waiting: isSet(object.waiting) ? globalThis.Boolean(object.waiting) : false,
      subtitles: globalThis.Array.isArray(object?.subtitles)
        ? object.subtitles.map((e: any) => SubtitlesObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubtitlesResponse): unknown {
    const obj: any = {};
    if (message.waiting !== false) {
      obj.waiting = message.waiting;
    }
    if (message.subtitles?.length) {
      obj.subtitles = message.subtitles.map((e) => SubtitlesObject.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubtitlesResponse>, I>>(base?: I): SubtitlesResponse {
    return SubtitlesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubtitlesResponse>, I>>(object: I): SubtitlesResponse {
    const message = createBaseSubtitlesResponse();
    message.waiting = object.waiting ?? false;
    message.subtitles = object.subtitles?.map((e) => SubtitlesObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamTranslationObject(): StreamTranslationObject {
  return { url: "", timestamp: 0 };
}

export const StreamTranslationObject = {
  encode(message: StreamTranslationObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTranslationObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTranslationObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTranslationObject {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: StreamTranslationObject): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamTranslationObject>, I>>(base?: I): StreamTranslationObject {
    return StreamTranslationObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamTranslationObject>, I>>(object: I): StreamTranslationObject {
    const message = createBaseStreamTranslationObject();
    message.url = object.url ?? "";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseStreamTranslationRequest(): StreamTranslationRequest {
  return { url: "", language: "", responseLanguage: "" };
}

export const StreamTranslationRequest = {
  encode(message: StreamTranslationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.language !== "") {
      writer.uint32(18).string(message.language);
    }
    if (message.responseLanguage !== "") {
      writer.uint32(26).string(message.responseLanguage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTranslationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTranslationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseLanguage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTranslationRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      responseLanguage: isSet(object.responseLanguage) ? globalThis.String(object.responseLanguage) : "",
    };
  },

  toJSON(message: StreamTranslationRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.responseLanguage !== "") {
      obj.responseLanguage = message.responseLanguage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamTranslationRequest>, I>>(base?: I): StreamTranslationRequest {
    return StreamTranslationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamTranslationRequest>, I>>(object: I): StreamTranslationRequest {
    const message = createBaseStreamTranslationRequest();
    message.url = object.url ?? "";
    message.language = object.language ?? "";
    message.responseLanguage = object.responseLanguage ?? "";
    return message;
  },
};

function createBaseStreamTranslationResponse(): StreamTranslationResponse {
  return { interval: 0, translatedInfo: undefined, pingId: undefined };
}

export const StreamTranslationResponse = {
  encode(message: StreamTranslationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.interval !== 0) {
      writer.uint32(8).int32(message.interval);
    }
    if (message.translatedInfo !== undefined) {
      StreamTranslationObject.encode(message.translatedInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.pingId !== undefined) {
      writer.uint32(24).int32(message.pingId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTranslationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTranslationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.translatedInfo = StreamTranslationObject.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pingId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTranslationResponse {
    return {
      interval: isSet(object.interval) ? streamIntervalFromJSON(object.interval) : 0,
      translatedInfo: isSet(object.translatedInfo)
        ? StreamTranslationObject.fromJSON(object.translatedInfo)
        : undefined,
      pingId: isSet(object.pingId) ? globalThis.Number(object.pingId) : undefined,
    };
  },

  toJSON(message: StreamTranslationResponse): unknown {
    const obj: any = {};
    if (message.interval !== 0) {
      obj.interval = streamIntervalToJSON(message.interval);
    }
    if (message.translatedInfo !== undefined) {
      obj.translatedInfo = StreamTranslationObject.toJSON(message.translatedInfo);
    }
    if (message.pingId !== undefined) {
      obj.pingId = Math.round(message.pingId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamTranslationResponse>, I>>(base?: I): StreamTranslationResponse {
    return StreamTranslationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamTranslationResponse>, I>>(object: I): StreamTranslationResponse {
    const message = createBaseStreamTranslationResponse();
    message.interval = object.interval ?? 0;
    message.translatedInfo = (object.translatedInfo !== undefined && object.translatedInfo !== null)
      ? StreamTranslationObject.fromPartial(object.translatedInfo)
      : undefined;
    message.pingId = object.pingId ?? undefined;
    return message;
  },
};

function createBaseStreamPingRequest(): StreamPingRequest {
  return { pingId: 0 };
}

export const StreamPingRequest = {
  encode(message: StreamPingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pingId !== 0) {
      writer.uint32(8).int32(message.pingId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamPingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamPingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pingId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamPingRequest {
    return { pingId: isSet(object.pingId) ? globalThis.Number(object.pingId) : 0 };
  },

  toJSON(message: StreamPingRequest): unknown {
    const obj: any = {};
    if (message.pingId !== 0) {
      obj.pingId = Math.round(message.pingId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamPingRequest>, I>>(base?: I): StreamPingRequest {
    return StreamPingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamPingRequest>, I>>(object: I): StreamPingRequest {
    const message = createBaseStreamPingRequest();
    message.pingId = object.pingId ?? 0;
    return message;
  },
};

function createBaseYandexSessionRequest(): YandexSessionRequest {
  return { uuid: "", module: "" };
}

export const YandexSessionRequest = {
  encode(message: YandexSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.module !== "") {
      writer.uint32(18).string(message.module);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): YandexSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYandexSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.module = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YandexSessionRequest {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      module: isSet(object.module) ? globalThis.String(object.module) : "",
    };
  },

  toJSON(message: YandexSessionRequest): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.module !== "") {
      obj.module = message.module;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YandexSessionRequest>, I>>(base?: I): YandexSessionRequest {
    return YandexSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YandexSessionRequest>, I>>(object: I): YandexSessionRequest {
    const message = createBaseYandexSessionRequest();
    message.uuid = object.uuid ?? "";
    message.module = object.module ?? "";
    return message;
  },
};

function createBaseYandexSessionResponse(): YandexSessionResponse {
  return { sign: "", expires: 0 };
}

export const YandexSessionResponse = {
  encode(message: YandexSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sign !== "") {
      writer.uint32(10).string(message.sign);
    }
    if (message.expires !== 0) {
      writer.uint32(16).int32(message.expires);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): YandexSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYandexSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sign = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expires = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YandexSessionResponse {
    return {
      sign: isSet(object.sign) ? globalThis.String(object.sign) : "",
      expires: isSet(object.expires) ? globalThis.Number(object.expires) : 0,
    };
  },

  toJSON(message: YandexSessionResponse): unknown {
    const obj: any = {};
    if (message.sign !== "") {
      obj.sign = message.sign;
    }
    if (message.expires !== 0) {
      obj.expires = Math.round(message.expires);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YandexSessionResponse>, I>>(base?: I): YandexSessionResponse {
    return YandexSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YandexSessionResponse>, I>>(object: I): YandexSessionResponse {
    const message = createBaseYandexSessionResponse();
    message.sign = object.sign ?? "";
    message.expires = object.expires ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
